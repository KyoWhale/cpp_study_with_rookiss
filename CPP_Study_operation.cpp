#include <iostream>
using namespace std;

// 데이터를 가공하는 방법
// a라는 이름의 바구니를 할당하고 안에 1을 넣는다
int a = 1;
// b라는 이름의 바구니를 할당하고 안에 2를 넣는다
int b = 2;

int main()
{
#pragma region 산술 연산
    // 대입연산
    int a = 1;
    int b = 1;
    a = b; // a에 b의 값을 넣어라
    
    // 사칙연산
    a = b + 3; // b에 3을 더한 값을 a에 넣어라
    a = b - 3; // b에 3을 뺀 값을 a에 넣어라
    a = b * 3; // b에 3을 곱한 값을 a에 넣어라
    a = b / 3; // b에 3을 나눈 값을 a에 넣어라
    a = b % 3; // b에 3을 나눈 후 나머지 값을 a에 넣어라

    // 복합연산
    a = a + 3; // 현재 a 값에 3을 더한 후 a에 넣어라
    a += 3; // 현재 a 값에 3을 더한 후 a에 넣어라
    a -= 3; // 이하 각 연산자에 동일
    a *= 3;
    a /= 3;

    // 증감연산자
    a = a + 1;
    a++;
    ++a;
    a--;
    --a;

    b = a++; // b = a -> a를 1 증가
    b = ++a; // a를 1 증가 -> b = a

    // ( )

#pragma endregion
#pragma region 비교 연산
    // 언제 필요한가?
    // ex) 체력이 0이 되면 사망
    // ex) 체력이 30% 이하이면 궁극기를 발동
    // ex) 경험치가 100 이상이면 레벨업

    // a == b : a와 b의 값이 같은가?
    // 같으면 1, 다르면 0
    bool isSame = a == b;

    // a != b : a와 b의 값이 다른가?
    // 다르면 1, 같으면 0
    bool isDifferent = a != b;

    // a > b : a가 b보다 큰가?
    // 크면 1, 작으면 0
    bool isGreater = a > b;

    // a < b : a가 b보다 작은가?
    // 작으면 1, 크면 0
    bool isSmaller = a < b;
#pragma endregion
#pragma region 논리 연산
    // 언제 필요한가? 조건에 대한 논리적 사고가 필요할 때
    // ex) 로그인할 때 아이디도 같고 비밀번호도 같아야 한다
    // ex) 길드 마스터이거나 OR 운영자 계정이면 길드 해산 가능

    // ! = not
    // 0이면 1, 그 외 0

    // && = and
    // a && b = 둘 다 1이면 1, 그 외 0
    // a를 만족하지 못하면 뒤의 조건을 확인하지 않고 바로 0이라는 결과를 알려줌

    // || = or (\\[엔터 위의 기호, 원화 기호] + 쉬프트 누르면서)
    // a || b = 둘 중 하나라도 1이면 1, 둘 다 0이면 0
    // a를 만족하면 뒤의 조건을 확인하지 않고 바로 1이라는 결과를 알려줌
#pragma endregion
#pragma region 비트 연산
    // 언제 필요한가? ( 사실 많이는 없음 )
    // 비트 단위의 조작이 필요할 때
    // - 대표적으로 BitFlag

    // ~ bitwise not
    // 단일 숫자의 모든 비트를 대상으로 0은 1, 1은 0으로 바꿈

    // & bitwise and
    // 두 숫자의 모든 비트 쌍을 대상으로 and를 한다

    // | bitwise or
    // 두 숫자의 모든 비트 쌍을 대상으로 or를 한다

    // ^ bitwise xor
    // 두 숫자의 모든 비트 쌍을 대상으로 xor를 한다 (같으면 0, 다르면 1)

    // << 비트 좌측 이동
    // 비트열을 N만큼 왼쪽으로 이동
    // 왼쪽으로 넘치는 N개의 비트는 버림. 새로 생성되는 N개의 비트는 0.
    // *2를 할 때 자주 보이는 패턴

    // >> 비트 우측 이동
    // 비트열을 N만큼 오른쪽으로 이동
    // 오른쪽으로 넘치는 N개의 비트는 버림. 
    // 왼쪽에 새로 생성되는 N개의 비트는
    // - 부호 비트가 존재할 경우 부호 비트를 따라감
    // - 아니면 0

    // 1011 0010
    // 1101 1001

    // 비트플래그
    // 불리언 노가다를 피할 수 있음
    // 하나의 정수 변수에 각 하나의 비트마다 상태를 저장시켜둠

    bool flag = (1 << 3); // (1<<3) 같은 식으로 써도 어셈블리에서는 바로 숫자로 바뀌기 때문에 성능적으로 차이가 없음
    flag |= (1 << 2);

    // bitmask (원하는 상태만 추출하기 위한 채)
    bool invincible = ((flag & (1 << 3)) != 0);
#pragma endregion
}