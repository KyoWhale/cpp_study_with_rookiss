#include <iostream>
using namespace std;

// 주석
/* 주석 */
/* 주석
주석
주석
주석 */

// 0이 아닌 초기화 값이 있으면 .data 영역
int hp = 100;
// 초기값이 0이거나, 초기값이 없는 변수라면 .bss 영역
int mp = 0;

// 기본적으로 signed(부호가 있는) 변수들임 unsigned를 하기 위해선 보통 접두사로 u를 붙임
char a; // 1바이트 -> 8비트 -> 2^8 (-128 ~ 127)
short b; // 2바이트 -> 16비트 -> 2^16 (-32768 ~ 32767)
int c; // 4바이트 -> 32비트 -> 2^32 (–2,147,483,648 ~ 2,147,483,647)
long long d; // 8바이트 -> 64비트 -> 2^64 (–9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)

unsigned char ua;
unsigned short ub;
unsigned int uc;
unsigned long ud;

// 자료형이 이렇게 세분화되어 있는 이유는 메모리와 네트워크에서 효율을 볼 수 있기 때문이다.
// 특히 게임에서
// 만약 실제로 사용되는 변수의 범위는 += 100 (1byte) 밖에 되지 않는데 long long (8byte)라면
// 7byte의 공간이 컴퓨터의 메모리에서 낭비되고 있는 것이고, 이를 만약 서버를 이용해서 통신하는 데이터였다면,
// 통신할 때마다 7byte의 전송 데이터를 낭비하는 것이다.
// 유저가 많아지면 많아질수록, 데이터 통신을 단위시간 당 더 많이할수록 손해가 커짐
// 그렇기 때문에 자료형을 제대로 선택하는 것이 좋음

// 참고) 이론적으로 양수만 존재할 수 있는 데이터는 unsinged를 사용하는 것이 바람직해보이지만
// 일부로 signed를 사용해서 음수가 나올 시에 프로그램을 크래시내는 방법을 선호하는 개발자들이 있기 때문에 의견이 갈림

int main()
{
    // 오버플로우
    b = 32767; // 0111 1111 1111 1111
    b = b + 1;
    cout << b << endl; // -32768

    // 언더플로우
    ub = 0;
    ub = ub - 1;
    cout << ub << endl; // 65535

    // cout << "hp : " << hp << " is remain" << endl;
}