bool isHighLevel = true;
bool isPlayer = true;
bool isMale = false;

// 사실 bool은 1 byte 정수
// 어셈블리에서 bool이라는건 없음
// 하지만 bool이라는 자료형을 씀으로서 참/거짓 둘 중 하나라는 힌트를 줌(가독성)

// bool은 1byte = 8bit, 왜 1bit만 사용하기에 7bit가 낭비되는데 왜
// 최소한의 단위 1byte

// 실수 (부동소수점) 뜰 부, 움직일 동 -> 소수점이 유동적으로 움직인다
// float double
// 3.1415926535
// 3.1415926535 = 0.31415926535 * 10 = 31.415926535 * 10^-1
// 정규화 = 0.31415926535 * 10
// 유효숫자 = 31415926535
// 10의 지수 = 1

// float 부호(1) 지수(8) 유효숫자(23) = 32bit = 4byte
// double 부호(1) 지수(11) 유효숫자(52) = 64bit = 8byte
// ex)-3.375라는 값을 저장
// 1) 2진수 변환 = 3 + 0.375 = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte라고가정하고 숫자 +127 만들어줌
// 예상결과 0b 1 1000000 1011000 0000 0000 0000 0000
// 00 00 58 c0 -> little endien
// 리틀 엔디언 : 캐스팅에 유리
// 빅 엔디언 : 숫자 비교에 유리
// 부동소수점은 항상 근사값 -> 항상 정확하지 않고
// 수가  커질수록 오차 범위도 매우 커짐
// 실수 2개를 ==로 비교하는 것은 지양

float attackSpeed = 0.369f; // 4byte
double attackSpeed2 = 123.4213; // 8byte 정밀도가 높음

#include <iostream>
#include <iomanip>
using namespace std;

int main() 
{
    float f = 3.14159265358979323846264f;
    double d = 3.14159265358979323846264;

    cout << setprecision(20);
    cout << f << endl;
    cout << d << endl;

    //     3.14159265358979323846264
    // f : 3.1415927410125732422
    // d : 3.141592653589793116
}